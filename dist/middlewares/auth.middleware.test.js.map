{"version":3,"sources":["../../src/middlewares/auth.middleware.test.ts"],"sourcesContent":["import jwt from 'jsonwebtoken'\nimport { Request, Response } from 'express'\nimport { authenticate } from './auth.middleware'\nimport { HttpException } from '@/exceptions'\nimport { prisma } from '@/lib'\nimport { StatusCode } from '@/utils'\n\nvi.mock('jsonwebtoken')\nvi.mock('@/lib/prisma')\nvi.mock('@/exceptions')\n\ndescribe('authenticate', () => {\n  const mockRequest = {\n    headers: {\n      authorization: 'Bearer mock-token',\n    },\n  } as Request\n\n  const mockResponse = {\n    status: vi.fn().mockReturnThis(),\n    json: vi.fn(),\n  } as unknown as Response\n\n  const mockNext = vi.fn()\n\n  it('should call next if the token matches SECRET_KEY', async () => {\n    const token = 'mock-secret-key'\n    mockRequest.headers.authorization = `Bearer ${token}`\n    await authenticate(mockRequest, mockResponse, mockNext)\n    expect(mockNext).toHaveBeenCalled()\n  })\n\n  it('should throw HttpException if no token is provided', async () => {\n    mockRequest.headers.authorization = undefined\n    await authenticate(mockRequest, mockResponse, mockNext)\n    expect(HttpException).toHaveBeenCalledWith('Unauthenticated', StatusCode.UNAUTHORIZED)\n    expect(mockNext).toHaveBeenCalledWith(expect.any(HttpException))\n  })\n\n  it('should return user not found if user does not exist', async () => {\n    ;(jwt.verify as any).mockReturnValue({ user: { id: 'mock-user-id' } })\n\n    // Mocking the Prisma findFirst method\n    const prismaUserFindFirstSpy = vi.spyOn(prisma.user, 'findFirst')\n    prismaUserFindFirstSpy.mockReturnValue(null as any)\n\n    await authenticate(mockRequest, mockResponse, mockNext)\n    // expect(mockResponse.status).toHaveBeenCalledWith(StatusCode.BAD_REQUEST)\n    // expect(mockResponse.json).toHaveBeenCalledWith({\n    //   message: 'User not found',\n    //   status: false,\n    // })\n\n    prismaUserFindFirstSpy.mockRestore()\n  })\n\n  it('should call next for catch block', async () => {\n    ;(jwt.verify as any).mockImplementation(() => {\n      throw new Error('Mock Error')\n    })\n    await authenticate(mockRequest, mockResponse, mockNext)\n    expect(mockNext).toHaveBeenCalledWith(expect.any(Error))\n  })\n})\n"],"names":["vi","mock","describe","mockRequest","headers","authorization","mockResponse","status","fn","mockReturnThis","json","mockNext","it","token","authenticate","expect","toHaveBeenCalled","undefined","HttpException","toHaveBeenCalledWith","StatusCode","UNAUTHORIZED","any","jwt","verify","mockReturnValue","user","id","prismaUserFindFirstSpy","spyOn","prisma","mockRestore","mockImplementation","Error"],"mappings":";;;;qEAAgB;gCAEa;4BACC;qBACP;uBACI;;;;;;AAE3BA,GAAGC,IAAI,CAAC;AACRD,GAAGC,IAAI,CAAC;AACRD,GAAGC,IAAI,CAAC;AAERC,SAAS,gBAAgB;IACvB,MAAMC,cAAc;QAClBC,SAAS;YACPC,eAAe;QACjB;IACF;IAEA,MAAMC,eAAe;QACnBC,QAAQP,GAAGQ,EAAE,GAAGC,cAAc;QAC9BC,MAAMV,GAAGQ,EAAE;IACb;IAEA,MAAMG,WAAWX,GAAGQ,EAAE;IAEtBI,GAAG,oDAAoD;QACrD,MAAMC,QAAQ;QACdV,YAAYC,OAAO,CAACC,aAAa,GAAG,CAAC,OAAO,EAAEQ,MAAM,CAAC;QACrD,MAAMC,IAAAA,4BAAY,EAACX,aAAaG,cAAcK;QAC9CI,OAAOJ,UAAUK,gBAAgB;IACnC;IAEAJ,GAAG,sDAAsD;QACvDT,YAAYC,OAAO,CAACC,aAAa,GAAGY;QACpC,MAAMH,IAAAA,4BAAY,EAACX,aAAaG,cAAcK;QAC9CI,OAAOG,yBAAa,EAAEC,oBAAoB,CAAC,mBAAmBC,iBAAU,CAACC,YAAY;QACrFN,OAAOJ,UAAUQ,oBAAoB,CAACJ,OAAOO,GAAG,CAACJ,yBAAa;IAChE;IAEAN,GAAG,uDAAuD;QACtDW,qBAAG,CAACC,MAAM,CAASC,eAAe,CAAC;YAAEC,MAAM;gBAAEC,IAAI;YAAe;QAAE;QAEpE,sCAAsC;QACtC,MAAMC,yBAAyB5B,GAAG6B,KAAK,CAACC,WAAM,CAACJ,IAAI,EAAE;QACrDE,uBAAuBH,eAAe,CAAC;QAEvC,MAAMX,IAAAA,4BAAY,EAACX,aAAaG,cAAcK;QAC9C,2EAA2E;QAC3E,mDAAmD;QACnD,+BAA+B;QAC/B,mBAAmB;QACnB,KAAK;QAELiB,uBAAuBG,WAAW;IACpC;IAEAnB,GAAG,oCAAoC;QACnCW,qBAAG,CAACC,MAAM,CAASQ,kBAAkB,CAAC;YACtC,MAAM,IAAIC,MAAM;QAClB;QACA,MAAMnB,IAAAA,4BAAY,EAACX,aAAaG,cAAcK;QAC9CI,OAAOJ,UAAUQ,oBAAoB,CAACJ,OAAOO,GAAG,CAACW;IACnD;AACF"}